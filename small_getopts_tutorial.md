# Small getopts tutorial

Description
When you want to parse command line arguments in a professional way, getopts is the tool of choice. Unlike its older brother getopt (note the missing s!), it's a shell builtin command. The advantages are:

* No need to pass the positional parameters through to an external program.
* Being a builtin, getopts can set shell variables to use for parsing (impossible for an external process!)
* There's no need to argue with several getopt implementations which had buggy concepts in the past (whitespace, …)
* getopts is defined in POSIX®.

Some other methods to parse positional parameters (without getopt(s)) are described in: How to handle positional parameters.

Note that getopts is not able to parse GNU-style long options (--myoption) or XF86-style long options (-myoption)!

###Terminology
It's useful to know what we're talking about here, so let's see… Consider the following command line:

`mybackup -x -f /etc/mybackup.conf -r ./foo.txt ./bar.txt`

These are all positional parameters, but they can be divided into several logical groups:

* -x is an option (aka flag or switch). It consists of a dash (-) followed by one character.
* -f is also an option, but this option has an associated option argument (an argument to the option -f): /etc/mybackup.conf. The option argument is usually the argument following the option itself, but that isn't mandatory. Joining the option and option argument into a single argument -f/etc/mybackup.conf is valid.
* -r depends on the configuration. In this example, -r doesn't take arguments so it's a standalone option like -x.
* ./foo.txt and ./bar.txt are remaining arguments without any associated options. These are often used as mass-arguments. For example, the filenames specified for cp(1), or arguments that don't need an option to be recognized because of the intended behavior of the program. POSIX® calls them operands.
To give you an idea about why getopts is useful, The above command line is equivalent to:

`mybackup -xrf /etc/mybackup.conf ./foo.txt ./bar.txt`

which is complex to parse without the help of getopts.

The option flags can be upper- and lowercase characters, or digits. It may recognize other characters, but that's not recommended (usability and maybe problems with special characters).

###How it works
In general you need to call getopts several times. Each time it will use the next positional parameter and a possible argument, if parsable, and provide it to you. getopts will not change the set of positional parameters. If you want to shift them, it must be done manually:
```
shift $((OPTIND-1))
# now do something with $@
```

Since getopts sets an exit status of FALSE when there's nothing left to parse, it's easy to use in a while-loop:
```
while getopts ...; do
  ...
done
```

getopts will parse options and their possible arguments. It will stop parsing on the first non-option argument (a string that doesn't begin with a hyphen (-) that isn't an argument for any option in front of it). It will also stop parsing when it sees the -- (double-hyphen), which means end of options.

### Used variables

| variable |	description | 
| --        | -- |
| OPTIND	|Holds the index to the next argument to be processed. This is how getopts "remembers" its own status between invocations. Also useful to shift the positional parameters after processing with getopts. OPTIND is initially set to 1, and needs to be re-set to 1 if you want to parse anything again with getopts
|OPTARG	|This variable is set to any argument for an option found by getopts. It also contains the option flag of an unknown option.
|OPTERR	|(Values 0 or 1) Indicates if Bash should display error messages generated by the getopts builtin. The value is initialized to 1 on every shell startup - so be sure to always set it to 0 if you don't want to see annoying messages! OPTERR is not specified by POSIX for the getopts builtin utility — only for the C getopt() function in unistd.h (opterr). OPTERR is bash-specific and not supported by shells such as ksh93, mksh, zsh, or dash.
getopts also uses these variables for error reporting (they're set to value-combinations which arent possible in normal operation).

###Specify what you want
The base-syntax for getopts is:

`getopts OPTSTRING VARNAME [ARGS...]`

where:

|    |   |
| -- | --|
|OPTSTRING	|tells getopts which options to expect and where to expect arguments (see below)
|VARNAME	|tells getopts which shell-variable to use for option reporting
|ARGS	|tells getopts to parse these optional words instead of the positional parameters

###The option-string

The option-string tells getopts which options to expect and which of them must have an argument. The syntax is very simple — every option character is simply named as is, this example-string would tell getopts to look for -f, -A and -x:

`getopts fAx VARNAME`

When you want getopts to expect an argument for an option, just place a : (colon) after the proper option flag. If you want -A to expect an argument (i.e. to become -A SOMETHING) just do:

`getopts fA:x VARNAME`

If the very first character of the option-string is a : (colon), which would normally be nonsense because there's no option letter preceding it, getopts switches to "silent error reporting mode". In productive scripts, this is usually what you want because it allows you to handle errors yourself without being disturbed by annoying messages.
